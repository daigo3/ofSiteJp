---
date: 2012/02/23 10:00:00
title: ベクトルの計算
summary: ベクトル計算の基本コンセプト
author: Keith Pasko
---
ベクトルは抽象的（理論的）な空間における方向と大きさを表します。取り急ぎ、今は2Dまたは3D空間を対象として考えましょう。これらの空間（世界）では、起点と基本となるベクトルを持っています。そして、この空間内に存在する全てのものは、これらの基本原理に基づいて作られます。  

例えば3D空間では、起点は(0, 0, 0)。基本ベクトルは、[1, 0, 0]、[0, 1, 0]、[0, 0, 1]　(2D空間においても同じですが、３番目の要素が必要ではありません。例）[1, 0]、[0, 1]、[0, 0])となります。 

これらの基本ベクトルについてx, y, z軸という方が、おそらく、良く知られている呼び方です。  
ベクトルに対して許可されている演算は、加算とスカラー乗法です。この演算で私たちは、空間内にいろいろなベクトルを生成することができます。

##ベクトル演算

###スカラー乗法
例えば、右方向へ3.14進みたいと仮定します。要素毎に乗算します。結果としては、次の様になります。  
[1 * 3.14,0 * 3.14,0 * 3.14] = [3.14,0,0]。  

同様に、上方向へ1.71進むことを考えてみましょう。同じく乗算結果は、  
[0,1,0] * 1.71 = [1 * 1.71,0 * 1.71,0 * 1.71] = [0,1.71,0]。  

スカラーによる乗法で、ベクトルが調整され、方向も変化していないことが分かります  
(スカラー値が負であれば、逆方向になることも分かります）。

<script src="../../js/vectors.js" type = "text/javascript">
</script>

<script src = "../../js/math_tut/diagrams.js" type = "text/javascript">
</script>

<canvas id = "mult" width = "600" height = "250"> </canvas>

<script type="text/javascript">
drawMult();
</script>


###加算
では、3.14右方向に移動し、その後1.71上方向に進むことを考えてみます。  
実は、上述２つのベクトルを単に加算することで実現することが可能です。  
[3.14,0,0] + [0,1.71,0] = [3.14 + 0,0 + 1.71,0 + 0] = [3.14,1.71,0]

これを"component-wise addition"と呼びます。ベクトルの要素毎に加算を行うということです（（例）x + x, y + y, z + z）。ベクトルの加算は、一方のベクトルの先端にもう一方のベクトルを付けることで表現できます。

<canvas id = "add" width = "600" height = "250">
</canvas>
<script type="text/javascript">
drawAdd();
</script>
<br/>

###アプリケーション
これらベクトル演算がどの様に役に立つのでしょう？　ではシンプルな例を見てみます。
ある空間にaとbの２つのポイントがあるとします。そして、一方を他方へ移動したいと考えてみます。
ここで、加算は、他方のベクトルの先端にもう一方のベクトルを付けるということを覚えていますか？

aからbへの方向（これをcと呼びましょう）をaに対して加算すると、b: a + c = bという結果を得られます。　私たちが探していたベクトルcは c = b - aとなります。

<canvas id = "diff" width = "600" height = "250">
</canvas>
<script type="text/javascript">
drawDiff();
</script>
<br/>

よって、私たちはaからbへの方向ベクトルcを知ることが出来ました。これが意味することは、aの先端にcを加算すると、bに移動出来るということです。

もし、0から1の値をcに掛けたものを加えていけば、徐々にaからbに移動をさせることが出来ます。

<canvas id = "aim" width = "600" height = "250">
</canvas>
<script type="text/javascript">
drawAim();
</script>

以上より、パーティクルをある位置から他の位置へイージングしながら発生させることが出来ます。これらの演算やコンセプトは3D空間でも同様に働きます。
3D空間において、ある位置から他の位置へ移動する為には、同様に、a + delta * (b - a)　のみで達成できます！

##その他の便利な演算

###長さ/標準化
###内積 / 投影 / 反射
###外積

###nerd stuff
このページで論じてきた“空間”は、〜加算とスカラー乗法の下で完了した〜ベクトル空間であり、全ての加算とスカラー乗法もまた同様に、同じ空間内のベクトルであると云う想像的な方法です。

標準規定は普通"e"で指示されます。　例）e1, e2, e3
また私たちが、ここで議論してきたものは、直行的な観点であることに注意してください。e1, e2, e3は、それぞれ長さが１で別のベクトルと90度の位置にあるものです。
違う例で云うと、aとbが１つのパス上に沿って存在すると仮定すると、cは、そのパスの接線の近似値の１つになります。

## openFrameworksでの表現
openFrameworksでのベクトルは、ofVec2fおよびofVec3fクラスとして実装されています。 これまでの加算や乗算については、演算子+と*を用い、同様に-(minus)や/(divide)も使用できます。
